import streamlit as st
import pandas as pd
import joblib
import numpy as np
from common import class_prediction_cosine_similarity

st.warning("""Demo Application Disclaimer

This application has been designed for demonstration and preview purposes. While the results generated by the model may not fully align with real-world scenarios, this service is intended to assess the model's fundamental capabilities and potential.

In the coming phases, precision will be exercised in refining the model, and adjustments will be made based on feedback received from the demonstration.""")

st.write("  ")
st.write("  ")
st.write("  ")

st.title("Overview")
st.markdown("This system employs machine learning to detect planets by analyzing specific parameters in observed astronomical data. Through meticulous parameter selection and analysis, the model uncovers potential signals indicative of exoplanetary presence. The system's success contributes to the expansion of our knowledge of celestial bodies beyond our solar system")
st.write(" ")
st.write(" ")
# Informations
st.sidebar.title("Parameters")

st.sidebar.info("This application uses the following parameters:\n\n"
         "- **Planet Letter**: The letter notation for a planet.\n"
         "B to Ä° [i] (1 to 8)\n"
         "- **Number of Stars**: Number of stars.\n"
         "- **Number of Planet Numbers**: Number of planets.\n"
         "- **Discovery Method**: Method of discovery.\n"
         "- **Discovery Locale**: Location of discovery.\n"
         "- **Distance (pc)**: Distance in parsecs.\n"
         "- **Distance (pc) Upper Unc**: Uncertainty in distance (upper bound).\n"
         "- **Distance (pc) Lower Unc**: Uncertainty in distance (lower bound).\n"
         "- **Planet Notes**: Notes related to the planet."
)

par1,par2,par3,par4 = st.columns(4)
# Parameters (Features)
with par1:
    pl_letter = st.slider('Planet Letter',1,4,8)
    st.write(" ")
    st.write(" ")
    sy_snum = st.slider('Number Of Stars',1,3,4)
with par2:
    sy_pnum = st.slider('Number of Planet Number',1,6,7)
    st.write(" ")
    st.write(" ")
    discoverymethod = st.slider('Discovery Method', 1,6,11)
with par3:
    disc_locale = st.slider('Discovery Locale',1,2,4)
    st.write(" ")
    st.write(" ")
    sy_dist = st.slider('Distance [pc]', 0.00034,0.5000,3720.23)
with par4:
    sy_disterr1 = st.slider('Distance [pc] Upper Unc',0.00034,0.04325,3720.23)
    st.write(" ")
    st.write(" ")
    sy_disterr2 = st.slider('Distance [pc] Lower Unc',0.0,1.000,2839.99965)
pl_nnotes = st.slider('Planet Notes',1,4,13)

col1, col2, col3 = st.sidebar.columns(3)
discovery_method_list = ['Radial Velocity', 'Imaging', 'Eclipse Timing V.','Transit', 'Astrometry', 'Disk Kinematics', 'Microlensing','Orbital Brightness M.', 'Pulsation Timing V.','Transit Timing V.', 'Pulsar Timing']

st.sidebar.subheader("Discovery Methods")
for i in discovery_method_list:
    st.sidebar.markdown("-  " + i)

discovery_locale_list = ['Ground', 'Space', 'Multiple Locales', 'Multiple Locale']
planet_letter = ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']


st.sidebar.subheader("Discovery Locale")
for i in discovery_locale_list:
    st.sidebar.markdown("- " + i)
st.sidebar.subheader("Planet Letters")
st.sidebar.text(planet_letter)

data = {'pl_letter': [pl_letter],
        'sy_snum': [sy_snum],
        'sy_pnum': [sy_pnum],
        'discoverymethod': [discovery_method_list[discoverymethod - 1]],
        'disc_locale': [discovery_locale_list[disc_locale - 1]],
        'sy_dist': [sy_dist],
        'sy_disterr1': [sy_disterr1],
        'sy_disterr2': [sy_disterr2],
        'pl_nnotes': [pl_nnotes]}



cachedir = 'joblib_cache_directory'
memory = joblib.Memory(cachedir)

# Using demo model
model = joblib.load("demo_model.joblib")

# Prediction
@memory.cache
def expensive_computation(user_input):
    result = model.predict(user_input)
    return result

# Take the features and convert them into arrays
user_input = np.array([pl_letter, sy_snum, sy_pnum, discoverymethod, disc_locale, sy_dist, sy_disterr1, sy_disterr2, pl_nnotes]).reshape(1, -1)

# Making predictions
predictions = expensive_computation(user_input)

# Cosine Similarity 
### The output that we estimated is going to be a regular number and we should find the linked planet based on the estimated number
cosine = class_prediction_cosine_similarity()

# The prediction is actually an array, we should make it normal object
normal_value = predictions.item()

text = cosine.prediction_cosine_similarity_calculation(normal_value)

# Result 
html_temp = f"""
    <style>
        body {{
            background-color: #000;
            background-image: url('https://cdn.mos.cms.futurecdn.net/8XiJkE2Znby5JKcyuFkF8E-1024-80.jpg');
            background-size: cover;
            background-position: center;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
        }}

        #planet-info {{
            text-align: center;
            margin-top: 30px;
            text-shadow: 2px 2px 4px #000000;
        }}
    </style>

    <div id="planet-info">
        <h1 style="font-size: 2em;">{text} has been chosen as the closest planet to your selection</h1>
    </div>
"""

st.markdown(html_temp, unsafe_allow_html=True)


st.divider()
# Spotify Sound Playlist
st.title("Planets Spotify Playlist")
st.info("Have you ever pondered the auditory essence of a planet? If so, then welcome to this playlist!")
st.components.v1.iframe("https://open.spotify.com/embed/playlist/4PyeDhy2lr0t0Jfb72Lxbk?utm_source=generator", 
                           width=750, height=380, scrolling=True)